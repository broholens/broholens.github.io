<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://broholens.github.io</id>
    <title>zz</title>
    <updated>2020-06-17T12:27:18.163Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://broholens.github.io"/>
    <link rel="self" href="https://broholens.github.io/atom.xml"/>
    <subtitle>这些都需要被记录</subtitle>
    <logo>https://broholens.github.io/images/avatar.png</logo>
    <icon>https://broholens.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, zz</rights>
    <entry>
        <title type="html"><![CDATA[发布包到PyPI]]></title>
        <id>https://broholens.github.io/post/P5yl4XkPx/</id>
        <link href="https://broholens.github.io/post/P5yl4XkPx/">
        </link>
        <updated>2020-06-16T15:20:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前提">前提：</h2>
<ul>
<li>已在<a href="https://pypi.org/account/register/">PyPI</a>上注册账号</li>
<li>github上已准备好待发布包</li>
</ul>
<h1 id="方案一手动执行">方案一：手动执行</h1>
<ul>
<li>已安装twine、wheel等包  <code>pip install twine wheel</code></li>
</ul>
<h3 id="发布流程">发布流程</h3>
<ol>
<li><strong>编写setup.py</strong>，可参考<a href="https://github.com/navdeep-G/setup.py">此项目</a>或<a href="https://github.com/broholens/pyfunctions">此项目</a></li>
<li><strong>打包并上传至PyPI</strong>，执行<code>setup.py upload</code>，需要输入PyPI账号及密码。</li>
</ol>
<h1 id="方案二github-actions">方案二：GitHub Actions</h1>
<p>GitHub Actions提供持续集成能力，可以用来在每次push/release时，自动打包并上传到PyPI。<br>
入门请查看<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">阮一峰的博客</a></p>
<h3 id="操作步骤">操作步骤</h3>
<h5 id="step-1-进入项目点击actions">Step 1: 进入项目，点击“Actions”</h5>
<figure data-type="image" tabindex="1"><img src="https://broholens.github.io/post-images/1592395665956.png" alt="" loading="lazy"></figure>
<h5 id="step-2创建workflow">Step 2：创建workflow</h5>
<p><img src="https://broholens.github.io/post-images/1592395792642.png" alt="" loading="lazy"><br>
<img src="https://broholens.github.io/post-images/1592395990636.png" alt="" loading="lazy"></p>
<h5 id="step-3配置pypi_username及pypi_password">Step 3：配置PYPI_USERNAME及PYPI_PASSWORD</h5>
<figure data-type="image" tabindex="2"><img src="https://broholens.github.io/post-images/1592396117747.png" alt="" loading="lazy"></figure>
<p>这样每次在release的时候，就会自动打包并上传到PyPI了。</p>
<p>🚦 上传成功后如果pip使用非PyPI源需要等一段同步时间，方可使用<code>pip install</code>下载；或更改pip源为PyPI下载。eg：<code>pip install pyfunctions==2020.6.17.11.52.7 -i https://pypi.python.org/simple</code></p>
<h3 id="thanks-to">Thanks To</h3>
<ol>
<li><a href="https://yq.aliyun.com/articles/644640">bdist_wheel报错</a></li>
<li><a href="https://help.github.com/en/actions/language-and-framework-guides/github-actions-for-python">github-actions-for-python</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python faker]]></title>
        <id>https://broholens.github.io/post/8iPAZ5DIt/</id>
        <link href="https://broholens.github.io/post/8iPAZ5DIt/">
        </link>
        <updated>2020-06-12T12:15:37.000Z</updated>
        <content type="html"><![CDATA[<p>faker提供伪造数据，包括但不限于手机号、地址、user-agent、isbn、身份证号(ssn)、信用卡信息、文章段落<br>
具体可以参考<a href="https://faker.readthedocs.io/en/stable/providers.html#">官方文档</a></p>
<h3 id="faker实现逻辑">faker实现逻辑</h3>
<ul>
<li>faker含有很多providers，每个provider用于提供一类fake数据。<br></li>
<li>faker支持多种语言，所以每类fake数据均有多种不同语言的provider类。<br></li>
<li>调用时首先通过proxy.py解析locale，支持在初始化时指定多个locale，然后将其他参数映射到factory.py生成faker对象，映射过程中会通过指定/默认locale加载指定/全部的providers。<br></li>
<li>每类fake数据都会提供一个Provider类(继承自BaseProvider)，这个Provider类提供本类数据的操作方法(如address类的city方法)，每种语言都会继承此Provider类，数据均来自于每种语言的__init__.py中。<br>
<br></li>
</ul>
<h3 id="示例">示例</h3>
<ul>
<li>基本示例</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; from faker import Faker
&gt;&gt;&gt; fake = Faker(locale=&quot;zh_CN&quot;)
&gt;&gt;&gt; fake.name_female()
'石红'
&gt;&gt;&gt; fake.name_male()
'郭飞'
&gt;&gt;&gt; fake.phone_number()
'13273633376'
&gt;&gt;&gt; fake.safe_email()
'kzhu@example.net'
&gt;&gt;&gt; fake.sentence()
'是否孩子事情公司解决.'
</code></pre>
<ul>
<li>创建自己的provider</li>
</ul>
<pre><code class="language-python">from faker import Faker
fake = Faker()

# first, import a similar Provider or use the default one
from faker.providers import BaseProvider

# create new provider class
class MyProvider(BaseProvider):
    def foo(self):
        return 'bar'

# then add new provider to faker instance
fake.add_provider(MyProvider)

# now you can use:
fake.foo()
# 'bar'
</code></pre>
<ul>
<li>使用指定单词创建sentence</li>
</ul>
<pre><code class="language-python">from faker import Faker
fake = Faker()

my_word_list = [
'danish','cheesecake','sugar',
'Lollipop','wafer','Gummies',
'sesame','Jelly','beans',
'pie','bar','Ice','oat' ]

fake.sentence()
# 'Expedita at beatae voluptatibus nulla omnis.'

fake.sentence(ext_word_list=my_word_list)
# 'Oat beans oat Lollipop bar cheesecake.'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python pathlib]]></title>
        <id>https://broholens.github.io/post/RhlpoFTTh/</id>
        <link href="https://broholens.github.io/post/RhlpoFTTh/">
        </link>
        <updated>2020-06-12T12:14:28.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; p = Path('.')

# 列举目录
&gt;&gt;&gt; [x for x in p.iterdir() if x.is_dir()]
[WindowsPath('.idea'), WindowsPath('__pycache__')]

# 列举文件
&gt;&gt;&gt; list(p.glob('**/*.py'))
[WindowsPath('debugger.py'), WindowsPath('ssh_connection.py'), WindowsPath('util.py'), WindowsPath('__init__.py')]

# 文件归属路径
&gt;&gt;&gt; p.cwd()
WindowsPath('D:/ODAEDebugger/backend')

# 文件绝对路径
&gt;&gt;&gt; p.resolve()
WindowsPath('D:/ODAEDebugger/backend/util.py')

# 文件/路径是否存在
&gt;&gt;&gt; p.exists()
True

# 是否是路径
&gt;&gt;&gt; p.is_file()
True

# 文件/路径stat
&gt;&gt;&gt; p.stat()
os.stat_result(st_mode=33206, st_ino=13510798882280617, st_dev=1245727358, st_nlink=1, st_uid=0, st_gid=0, st_size=112, st_atime=1590832618, st_mtime=1590738985, st_ctime=1590738985)

# 文件后缀与文件名
&gt;&gt;&gt; p.name
'util.py'
&gt;&gt;&gt; p.suffix
'.py'
&gt;&gt;&gt; p.stem
'util'

# 读写文件  函数内部已使用with open封装
&gt;&gt;&gt; p.read_text()
&quot;import json\n\n\ndef load_json_file(file_path):\n    with open(file_path, 'r')as f:\n        return json.load(f)&quot;
&gt;&gt;&gt; p.write_text('aaa')
3
&gt;&gt;&gt; p.read_text()
'aaa'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[127.0.0.1、localhost、0.0.0.0]]></title>
        <id>https://broholens.github.io/post/6387ia0vK/</id>
        <link href="https://broholens.github.io/post/6387ia0vK/">
        </link>
        <updated>2020-06-11T10:37:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="127001">127.0.0.1</h2>
<p>属于环回地址，环回地址：所有发往该类地址的数据包都应该被loop back。<br><br>
使用这个地址发送数据，则数据包不会出现在网络传输过程中。</p>
<h4 id="用途">用途</h4>
<ul>
<li>测试某台机器上的网络设备，操作系统或者TCP/IP实现是否工作正常：ping 127.0.0.1</li>
</ul>
<h2 id="0000">0.0.0.0</h2>
<ul>
<li>在服务器中，0.0.0.0指的是本机上的所有IPV4地址</li>
<li>在路由中，0.0.0.0表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。</li>
</ul>
<h4 id="用途-2">用途</h4>
<ul>
<li>如果主机有大小网两个IP，且主机上一个服务监听的地址为0.0.0.0，则两个IP均可访问该服务。</li>
</ul>
<h2 id="localhost">localhost</h2>
<p>域名。默认指向127.0.0.1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git commit --amend修改commit信息后，push报错]]></title>
        <id>https://broholens.github.io/post/git-commit-amend-xiu-gai-commit-xin-xi-hou-push-bao-cuo/</id>
        <link href="https://broholens.github.io/post/git-commit-amend-xiu-gai-commit-xin-xi-hou-push-bao-cuo/">
        </link>
        <updated>2020-06-10T23:36:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="情景复现">情景复现</h3>
<p>commit并push到远端的情况下修改commit信息</p>
<ol>
<li><code>git commit -m &quot;commit message here&quot;</code></li>
<li><code>git push</code></li>
<li><code>git commit --amend</code></li>
<li><code>git push</code><br>
报错如下：<br>
<code>hint: Updates were rejected because the tip of your current branch is behind</code></li>
</ol>
<h3 id="解决方式">解决方式：</h3>
<p>上述第4步使用<code>git push -f</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://broholens.github.io/post/hello-gridea/</id>
        <link href="https://broholens.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>